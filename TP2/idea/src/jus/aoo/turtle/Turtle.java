package jus.aoo.turtle;import static jus.aoo.geometrie.DrawingSpace.Repere.CENTRE;import jus.aoo.geometrie.DrawingSpace;import jus.aoo.geometrie.Image;import jus.aoo.geometrie.Point;import jus.aoo.geometrie.Segment;import jus.aoo.geometrie.Vecteur;import jus.aoo.geometrie.Intersection;import jus.util.assertion.*;/** * Réalise les fonctions d'une tortue du moodle Logo * @author	P.Morat ou http://imag.fr/Philippe.Morat ... * @version	1.0 * date : 1/9/99 * @invariant Cohérent : Math.abs(Cap().module()-1) < Vecteur.EPSILON * CHANGED: v1.1.2 * @invariant Visible : -feuille.getWidth()/2 <= position().abscisse() &&  position().abscisse() < feuille.getWidth()/2 *                       && -feuille.getHeight()/2 <= position().ordonnee() && position().ordonnee() < feuille.getHeight()/2 * @motcle tortue, Logo, tracé, dessin * @see <a href="Turtle.java">Turtle</a> */public class Turtle {	protected DrawingSpace feuille; // l'espace de déplacement de la tortue	protected static final String imageFile = "/jus/aoo/turtle/Turtle.gif"; //le nom de l'image matérialisant la tortue.	protected Image image; //l'image de la tortue	protected boolean estLeve;  // état de la plume	protected Point position;   // la position courante de la tortue	protected Vecteur cap;      // direction courante de la tortue	/**	* le constructeur de tortue	* @param feuille la surface explorée	* @require fmtOk : feuille!=null	*/	public Turtle(DrawingSpace feuille) {		this.feuille = feuille;		try{			position = new Point(0, 0);		}catch(Require e) {		}		cap = new Vecteur(Vecteur.UNITE);		estLeve = true;		/* On réalise des transformations sur le support de dessin pour avoir le zero au centre de l'espac		 * l'orientation positive des ordonnées vers le haut et le cap zero à droite.		 * On maintient cependant la rotation dans le sens anti-horaire */ 		feuille.setRepere(CENTRE);		image = new Image(position, imageFile);		feuille.addPermanent(image);	}	/**		 * Fait avancer la tortue de d pas	 * @param d la distance à parcourir	 * @require argumentValide : d >= 0	 * @require destinationVisible : destinationVisible(d, true)	 * @ensure CapInchange : _cap().equals(cap())	 * @ensure DeplacementOk : new Vecteur(_position(), position()).module()-d < Vecteur.EPSILON	 * @ensure capOk : new Vecteur(_position(), position()).colineaire(cap())	 */	public void avancer(int d) {		if(!destinationVisible(d, new Vecteur(cap))) throw new Require("not_destinationVisible");		Point _position = new Point(position);		Vecteur v = new Vecteur(cap);		v.homothetie(d);		position.translation(v);		image.translation(v);		if(!estLeve){			feuille.add(new Segment(_position, position));		}else {			feuille.repaint();		}		//CHANGED: v1.1.2		invariants();	}	/**	 * CHANGED: v1.1.4	 * Fais avancer la tortue au maximum de d pas sans la faire sortir de la fenêtre.	 * @param d la distance maximum à parcourir	 */	public void avancerMax(int d){		// calcul du vecteur de déplacement maximum		Vecteur wDepl = new Vecteur(cap());		wDepl.homothetie(d);		// calcul du vecteur de déplacement réel		Vecteur wVecteurR = calculVecteurReel(wDepl);		// déplacement de la tortue selon le vecteur réel		avancer((int) wVecteurR.module());	}	/**		 * Fait reculer la tortue de d pas	 * @param d la distance à parcourir	 * @require argumentValide : d >= 0	 * @require destinationVisible : destinationVisible(d, false)	 * @ensure CapInchange : _cap().equals(cap())	 * @ensure DeplacementOk : new Vecteur(_position(), position()).module()-d < Vecteur.EPSILON	 * @ensure capOk : new Vecteur(_position(), position()).colineaire(cap())	 */	public void reculer(int d) {		if(!destinationVisible(d, cap.oppose())) throw new Require("not_destinationVisible");		Point _position = new Point(position);		Vecteur v = cap.oppose();		v.homothetie(d);		position.translation(v);		image.translation(v);		if(!estLeve) {			feuille.add(new Segment(_position, position));		}else {			feuille.repaint();		}		//CHANGED: v1.1.2		invariants();	}	/**	 * CHANGED: v1.1.4	 * Fais reculer la tortue au maximum de d pas sans la faire sortir de la fenêtre.	 * @param d la distance maximum à parcourir	 */	public void reculerMax(int d){		// calcul du vecteur de déplacement maximum		Vecteur wDepl = cap().oppose();		wDepl.homothetie(d);		// calcul du vecteur de déplacement réel		Vecteur wVecteurR = calculVecteurReel(wDepl);		// déplacement de la tortue selon le vecteur réel		reculer((int) wVecteurR.module());	}	/**		* Fait tourner la à droite d'un angle a	* @param a l'angle de rotation en degré	* @require argumentValide : a>=0	* @ensure PositionInchange : new Vecteur(_position(),position()).module() < Vecteur.EPSILON	*/	public void droite(int a) {		cap.rotation((double) - a);		image.rotation(-a);		feuille.repaint();	}	/**		* Fait tourner la tortue à gauche d'un angle a	* @param a l'angle de rotation en degré	* @require argumentValide : a >= 0	* @ensure PositionInchange : new Vecteur(_position(),position()).module() < Vecteur.EPSILON	*/	public void gauche(int a) {		cap.rotation((double)a);		image.rotation(a);		feuille.repaint();	}	/**		* Lève la plume	* @ensure PlumeLevée : estLeve()	*/	public void lever() {		estLeve = true;	}	/**		* Baisse la plume	* @ensure PlumeLevée : !estLeve()	*/	public void baisser() {		estLeve = false;	}	/**		* Restitue la représentation textuelle de la tortue	* @return la chaine	*/	public String toString() {		return "Tortue["+position+","+cap+"]";	}	/**	* Restitue la position de la tortue	* @return le Point de référence de la tortue	*/	public Point position() {		return new Point(position);	}	/**		* Restitue le cap de la tortue	* @return le Vecteur de référence de la tortue	*/	public Vecteur cap()  {return new Vecteur(cap);}	/**		* Restitue l'état de la plume	* @return true si la plume est levée	*/	public  boolean estLeve() {		return estLeve;	}	/**	 * CHANGED: v1.1.2	 * Retoune vrai le point définissant la position courante de la tortue se trouve dans l'espace visible de la feuille.	 * @return true si le point définissant la position courante de la tortue est dans l'espace visible de la feuille. False sinon	 */	public boolean isVisible(){		return isVisible(this.position());	}	/**	 * CHANGED: v1.1.2	 * Retoune vrai si le point passé en paramètre se trouve dans l'espace visible de la feuille.	 * @param aPoint un point	 * @return true si le point est dans l'espace visible de la feuille. False sinon	 */	public boolean isVisible(Point aPoint){		double wWidth = feuille.getWidth() / 2;		double wHeight = feuille.getHeight() / 2;		return -wWidth <= aPoint.abscisse()				&& aPoint.abscisse() <= wWidth				&& -wHeight <= aPoint.ordonnee()				&& aPoint.ordonnee() <= wHeight;	}	/**	 * CHANGED: v1.1.2	 * Test de tous les invariants de la classe. La fonction Leve des exceptions de type Invariant si jamais un invariant	 * n'est pas vérifié	 */	protected void invariants(){		if (!isVisible()) throw new Invariant("not_Visible");		if (!(Math.abs(cap().module()-1) < Vecteur.EPSILON)) throw new Invariant("not_Cohérent");	}	/**	 * CHANGED: v1.1.3	 * retourne vrai si le point de destinatin est visible après un déplacement de longueur aD suivant le vecteur aVecteur	 * @param aD la distance à parcourir	 * @param aVecteur vecteur de déplacement	 * @return true si la destination est visible. False sinon	 */	protected boolean destinationVisible(int aD, Vecteur aVecteur){		Point wPoint = new Point(position);		aVecteur.homothetie(aD/aVecteur.module());		wPoint.translation(aVecteur);		return isVisible(wPoint);	}	/**	 * CHANGED: v1.1.4	 * Calcul du vecteur de déplacement maximum sans sortir de la fenêtre	 * @param aVecteur : direction du déplacement	 * @return Vecteur de déplacement maximum	 */	private Vecteur calculVecteurReel(Vecteur aVecteur) {		// Création du vecteur qui sera retourné comme étant le vecteur unité de aVecteur		Vecteur wReturned = new Vecteur(aVecteur);		wReturned.homothetie(1/wReturned.module());		// Construction des 4 angles de la fenêtre		Point wP1 = new Point((-feuille.getWidth()/2), (feuille.getHeight()/2));	// point en haut à gauche		Point wP2 = new Point((feuille.getWidth()/2), (feuille.getHeight()/2));		// point en haut à droite		Point wP3 = new Point((-feuille.getWidth()/2), (-feuille.getHeight()/2));	// point en bas à gauche		Point wP4 = new Point((feuille.getWidth()/2), (-feuille.getHeight()/2));	// point en bas à droite		// Construction des 4 segments formant les bors de la fenêtre		Segment wHaut = new Segment(wP1, wP2);		// coté haut de la fenêtre		Segment wDroit = new Segment(wP2, wP4);		// coté droit de la fenêtre		Segment wBas = new Segment(wP3, wP4);		// coté bas de la fenêtre		Segment wGauche = new Segment(wP1, wP3);	// coté gauche de la fenêtre		// Construction du segment de déplacement complet		Segment wSegment = new Segment(position(), aVecteur); // le segment partant de la position actuelle et suivant le vecteur v		// Construction des 4 points intersctions entre le segment de déplacement et les bors de la fenêtre		Intersection wIDroit = new Segment(wDroit).pointIntersection(wSegment);		Intersection wIHaut = new Segment(wHaut).pointIntersection(wSegment);		Intersection wIGauche = new Segment(wGauche).pointIntersection(wSegment);		Intersection wIBas = new Segment(wBas).pointIntersection(wSegment);		// Création des vecteurs entre le point original et les intersections		Vecteur wVectRes1 = new Vecteur(position(), wIDroit.point);//construction du vecteur reliant la position au point d'intersection		Vecteur wVectRes2 = new Vecteur(position(), wIHaut.point);		Vecteur wVectRes3 = new Vecteur(position(), wIGauche.point);		Vecteur wVectRes4 = new Vecteur(position(), wIBas.point);		// Calcul des modules des vecteurs		double wMod1 = wVectRes1.module();		double wMod2 = wVectRes2.module();		double wMod3 = wVectRes3.module();		double wMod4 = wVectRes4.module();		int wMin = (int) Math.min(wMod1, (Math.min(wMod2, Math.min(wMod3, wMod4))));		// Application de l'homotéthie avec le plus faible des modules des vecteurs trouvés		wReturned.homothetie(wMin);		return wReturned;	}}